<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Introducción a los paradigmas de computación | Teoría de la computación</title>
    <meta name="description" content="Apuntes de los contenidos dados en la cátedra.">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/teoria-de-la-computacion/images/icons/icon-72x72.png">
  <link rel="manifest" href="/teoria-de-la-computacion/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/teoria-de-la-computacion/images/icons/icon-152x152.png">
  <link rel="mask-icon" href="/teoria-de-la-computacion/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/images/icons/icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/teoria-de-la-computacion/assets/css/0.styles.619da894.css" as="style"><link rel="preload" href="/teoria-de-la-computacion/assets/js/app.3e879b2a.js" as="script"><link rel="preload" href="/teoria-de-la-computacion/assets/js/2.1d24719b.js" as="script"><link rel="preload" href="/teoria-de-la-computacion/assets/js/12.d51f82e2.js" as="script"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/10.369e8a76.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/11.570fb543.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/13.2e64a1c9.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/14.07081446.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/3.1dc01336.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/4.7d2fc014.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/5.abbda57c.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/6.e6e70a20.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/7.578cb8b4.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/8.9c810090.js"><link rel="prefetch" href="/teoria-de-la-computacion/assets/js/9.b29aaa5b.js">
    <link rel="stylesheet" href="/teoria-de-la-computacion/assets/css/0.styles.619da894.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/teoria-de-la-computacion/" class="home-link router-link-active"><!----> <span class="site-name">Teoría de la computación</span></a> <div class="links"><!----> <div class="user-settings"><a href="#" class="settings-button"><svg aria-hidden="true" data-prefix="fas" data-icon="cog" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-cog fa-w-16 settings-icon"><path fill="currentColor" d="M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"></path></svg></a> <div class="user-settings-menu" style="display:none;"><div class="theme-options"><!----> <!----> <!----> <div class="dark-theme-options toggle-option"><label for="dark-theme-toggle">Modo dark</label> <label class="switch"><input type="checkbox"> <span class="slider round" style="background-color:#ccc;"></span></label></div> <!----> <!----></div></div></div> <!----> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/teoria-de-la-computacion/" class="nav-link">
  Inicio
</a></div><div class="nav-item"><a href="/teoria-de-la-computacion/clases-teoria/" class="nav-link">
  Teoría
</a></div><div class="nav-item"><a href="/teoria-de-la-computacion/lecturas/.html" class="nav-link">
  Práctica
</a></div><div class="nav-item"><a href="/teoria-de-la-computacion/lecturas/" class="nav-link router-link-active">
  Lecturas
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/teoria-de-la-computacion/" class="nav-link">
  Inicio
</a></div><div class="nav-item"><a href="/teoria-de-la-computacion/clases-teoria/" class="nav-link">
  Teoría
</a></div><div class="nav-item"><a href="/teoria-de-la-computacion/lecturas/.html" class="nav-link">
  Práctica
</a></div><div class="nav-item"><a href="/teoria-de-la-computacion/lecturas/" class="nav-link router-link-active">
  Lecturas
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Introducción a los paradigmas de computación</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/teoria-de-la-computacion/lecturas/lectura2.html#programacion-orientada-a-objetos" class="sidebar-link">Programación Orientada a Objetos</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/teoria-de-la-computacion/lecturas/lectura2.html#programacion-funcional" class="sidebar-link">Programación funcional</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/teoria-de-la-computacion/lecturas/lectura2.html#programacion-logica" class="sidebar-link">Programación lógica</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="introduccion-a-los-paradigmas-de-computacion"><a href="#introduccion-a-los-paradigmas-de-computacion" class="header-anchor">#</a> Introducción a los paradigmas de computación</h1> <p>Al principio los lenguajes de programación se basaron en el <strong>modelo de computación Von Neumann</strong>, que propuso que el programa se almacenara en la máquina antes de ejecutarse y a su vez:</p> <ol><li>La ejecución secuencial de instrucciones.</li> <li>El uso de variables para la representación de las posiciones de memoria.</li> <li>El uso de la asignación para cambiar el valor de las variables.</li></ol> <p>Estos lenguajes se conocen como <strong>imperativos</strong>, porque sus instrucciones representan órdenes. También se les ha denominado <strong>procedurales</strong>, aunque no tengan nada que ver con el concepto de abstracción de procedimiento.</p> <p>No es requisito que la <strong>computación</strong> sea una secuencia de instrucciones donde cada una opere sobre un dato (esto se conoce como <strong>cuello de botella de Von Neumann</strong>), sino que puede ser <strong>paralela</strong>, actuar sobre diferentes datos simultáneamente, o <strong>no determinista</strong> e independiente del orden. Por estas distintas formas de describir la computación se considera a los lenguajes imperativos un paradigma o patrón (<strong>paradigma imperativo</strong>).</p> <p>Dos paradigmas diferentes al anterior, basados en abstracciones matemáticas, son el <strong>funcional</strong> que usa la noción de función según plantea en el <strong>lambda cálculo</strong>, y el <strong>paradigma lógico</strong> que se basa en la lógica simbólica. Permiten que tareas muy complejas se describan precisa y concisamente, facilitando la verificación de lo programas.</p> <p>En algunas bibliografías se denomina <strong>programación declarativa</strong> al grupo formado por la  programación funcional y la lógica, por la gran diferencia con el resto de lenguajes. En estos, las propiedades se declaran y no se especifica la secuencia de ejecución.</p> <p>Un cuarto paradigma es el de la <strong>programación orientada objetos</strong> (POO), que facilita la reutilización de programas y su ampliación, siendo más <em>natural</em> la elaboración de código que se quiere ejecutar. Sin embargo de alguna manera este paradigma es también imperativo pues se basa en una ejecución secuencial sobre un conjunto cambiante de posiciones de memoria. La diferencia es que los programas están formados por pequeñas piezas de código, cuyas interacciones están controladas y se cambian fácilmente. En la práctica este tipo de programación tiene dificultad en predecir con precisión el comportamiento y determinar la corrección de programas. Actualmente es un estándar ampliamente utilizado.</p> <p>A modo de entender los paradigmas nombrados, vamos a calcular el máximo común divisor (MCD) en cada uno de ellos para ver sus similitudes y diferencias. Recuerda que los lenguajes de hoy en día se pueden clasificar en diferentes paradigmas.</p> <h2 id="programacion-orientada-a-objetos"><a href="#programacion-orientada-a-objetos" class="header-anchor">#</a> Programación Orientada a Objetos</h2> <p>Este paradigma se basa en la idea de que un objeto se puede describir como una colección de posiciones de memoria junto con todas las operaciones que pueden cambiar los valores de dichas posiciones. Los objetos se agrupan en clases que representan a todos los que tienen las mismas propiedades. Las clases se definen mediante declaraciones parecidas a las de los tipos estructurados en C o Pascal. Tras la declaración de una clase, se pueden crear objetos concretos a partir de la misma, mediante la instanciación de la clase.</p> <p>Para implementar el ejercicio de MCD lo haremos en Java:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntWithGcd</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">public</span> <span class="token class-name">IntWithGcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span> value <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">intVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">int</span> gcd <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> dividendo <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">int</span> divisor <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>divisor <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> auxDivisor <span class="token operator">=</span> divisor<span class="token punctuation">;</span>
            <span class="token keyword">int</span> resto <span class="token operator">=</span> dividendo <span class="token operator">%</span> divisor<span class="token punctuation">;</span>
            <span class="token keyword">int</span> cociente <span class="token operator">=</span> dividendo<span class="token operator">/</span>auxDivisor<span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dividendo <span class="token operator">+</span> <span class="token string">&quot;/&quot;</span> <span class="token operator">+</span> divisor <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> cociente <span class="token operator">+</span> <span class="token string">&quot;  R: &quot;</span> <span class="token operator">+</span> resto<span class="token punctuation">)</span><span class="token punctuation">;</span>
            divisor <span class="token operator">=</span> resto<span class="token punctuation">;</span>
            dividendo <span class="token operator">=</span> auxDivisor<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dividendo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>En este ejemplo se define una nueva clase mediante:</p> <ol><li>Un constructor. Estos asignan memoria y aportan valores iniciales para los datos del objeto.</li> <li>Un método de acceso a este valor (inVal).</li> <li>El método gcd.</li> <li>El entero <em>value</em>.</li></ol> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Máximo común divisor entre 8 y 18!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">IntWithGcd</span> x<span class="token punctuation">;</span>
        x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWithGcd</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">gcd</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;El resultado es: &quot;</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>La clase IntWithGcd se utiliza definiendo un nombre de variablepara contener un objeto de la clase: IntWithGcd x;
Al principio la variable x no contiene la referencia a un objeto, por lo que hay que instanciarla con la sentencia:</p> <div class="language-Java extra-class"><pre class="language-java"><code>x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWithGcd</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>A continuación se llama al método gcd mediante:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">gcd</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Y tras la ejecución de esta sentencia, la variable y contendrá el valor 2, que es el máximo común divisor de 18 y 8.</p> <h2 id="programacion-funcional"><a href="#programacion-funcional" class="header-anchor">#</a> Programación funcional</h2> <p>La computación en el paradigma funcional se fundamenta en la evaluación de funciones o en la aplicación de funciones a valores conocidos, por lo que también se denominan lenguajes aplicativos. El mecanismo básico es la evaluación de funciones, con las siguientes características:</p> <ul><li>La transferencia de valores como parámetros de las funciones que se evalúan.</li> <li>La generación de resultados en forma de valores devueltos por las funciones.</li></ul> <p>Este proceso no involucra de ningún modo a la asignación de una variable a una posición de memoria, aspecto que le aleja de la programación orientada a objetos. Tampoco las operaciones repetitivas se presentan por ciclos (que requieren de <strong>variables de control</strong> para su terminación), sino mediante las <strong>funciones recursivas</strong>, un mecanismo muy potente.</p> <p>Que un lenguaje de programación prescinda de las variables y ciclos, ofrece ventajas relacionadas con la verificación de lo programas. Volviendo al ejemplo de MCD haremos dicha función en Haskell:</p> <div class="language-Haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">gcd</span> <span class="token hvariable">u</span> <span class="token hvariable">v</span>
    <span class="token operator">|</span> <span class="token hvariable">v</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">-&gt;</span> <span class="token hvariable">u</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token builtin">gcd</span> <span class="token hvariable">v</span> <span class="token punctuation">(</span><span class="token builtin">mod</span> <span class="token hvariable">u</span> <span class="token hvariable">v</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>En la primer línea se define la cabecera de la función <em>gcd</em> y sus dos <strong>parámetros formales</strong> <em>u</em> y <em>v</em>.</li> <li>En la segunda se comprueba si <em>v</em> es igual a 0, en cuyo caso devuelve el valor de <em>u</em>.</li> <li>En la tercera se establece la recursión, llamando a <em>gcd</em> nuevamente con los parámetros <em>v</em> y el resto de dividir <em>u</em> entre <em>v</em>.</li></ul> <h2 id="programacion-logica"><a href="#programacion-logica" class="header-anchor">#</a> Programación lógica</h2> <p>En un lenguaje de programación lógica, un programa está formado por un conjunto de sentencias que describen lo que es <em>verdad</em> o <em>conocido</em> con respecto a un problema, en vez de indicar la secuencia de pasos que llevan al resultado. No necesita de abstracciones de control condicionales ni de ciclos ya que el control lo aporta el modelo de inferencia lógica que subyace.</p> <p>La definición de MCD es la siguiente:</p> <ul><li>El <em>gcd</em> de <em>u</em> y <em>v</em> es <em>u</em> si <em>v</em> es 0.</li> <li>El <em>gcd</em> de <em>u</em> y <em>v</em> es el <em>gcd</em> de <em>v</em> y de <em>u mod v</em>, si <em>v</em> no es 0.</li></ul> <p>Y esto puede programarse en Prolog, con el predicado (que podrá ser verdad o falso) gcd(U,V,X), que se entiende como &quot;es verdad que el gcd de U y V es X&quot;:</p> <div class="language-Prolog extra-class"><pre class="language-prolog"><code><span class="token function">gcd</span><span class="token punctuation">(</span><span class="token variable">U</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">U</span><span class="token punctuation">)</span> <span class="token operator">.</span>
<span class="token function">gcd</span><span class="token punctuation">(</span><span class="token variable">U</span><span class="token punctuation">,</span> <span class="token variable">V</span><span class="token punctuation">,</span> <span class="token variable">U</span><span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token operator">not</span> <span class="token punctuation">(</span><span class="token variable">V</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token variable">Y</span> <span class="token operator">is</span> <span class="token variable">U</span> <span class="token operator">mod</span> <span class="token variable">V</span><span class="token punctuation">,</span>
                <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token variable">V</span><span class="token punctuation">,</span> <span class="token variable">Y</span><span class="token punctuation">,</span> <span class="token variable">X</span><span class="token punctuation">)</span> <span class="token operator">.</span>
</code></pre></div><p>Así, para calcular el MCD entre 18 y 8, se deberá escribir la consulta PROLOG:</p> <div class="language-Prolog extra-class"><pre class="language-prolog"><code><span class="token operator">?-</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token variable">X</span><span class="token punctuation">)</span> <span class="token operator">.</span>
</code></pre></div><p>que busca un valor que, asignado a X, haga cierta esa pregunta.</p> <p>En Prolog un programa es un conjunto de sentencias, denominadas <strong>cláusulas</strong> de la forma: a :- b,c,d. que es una afirmación que se entiende como &quot;<em>a</em> es cierto, o resoluble, si <em>b</em>, a continuación <em>c</em> y finalmente <em>d</em> son ciertos o resolubles en este orden&quot;. A diferencia de las funciones de la programación funcional, Prolog requiere de variables para representar los valores de las funciones, aunque no representan posiciones de memoria. En Prolog las variables se distinguen sintácticamente de otros elementos del lenguaje (por ejemplo, empezando por mayúsculas).</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Última actualización:</span> <span class="time">hace 20 días</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/teoria-de-la-computacion/lecturas/lectura1.html" class="prev">
        Paradigmas de la computación
      </a></span> <span class="next"><a href="/teoria-de-la-computacion/lecturas/lectura3.html">
        Descripción de los lenguajes de programación
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/teoria-de-la-computacion/assets/js/app.3e879b2a.js" defer></script><script src="/teoria-de-la-computacion/assets/js/2.1d24719b.js" defer></script><script src="/teoria-de-la-computacion/assets/js/12.d51f82e2.js" defer></script>
  </body>
</html>
